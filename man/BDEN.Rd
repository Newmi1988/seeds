% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BDEN.R
\name{BDEN}
\alias{BDEN}
\title{Bayesian Dynamic Elastic Net}
\usage{
BDEN(observation_time, observations, initialvalues, parameters, inputData,
  numberstates, std, settings, model, mcmc_component, loglikelihood_func,
  gibbs_update, ode_sol, measFunc, numbertrialsstep = 15,
  numbertrialseps = 500 * 4, numbertrialinner = 10, lambda = 0.001,
  Grad_correct = 0, alpha = c(1, 1, 1, 1), beta_init = c(1, 1, 1, 0.1))
}
\arguments{
\item{observation_time}{observed time points}

\item{observations}{observed state dynamics e.g. protein concentrations}

\item{initialvalues}{initial values}

\item{parameters}{model parameters}

\item{inputData}{discrete input function e.g. stimuli}

\item{numberstates}{number of modeled states}

\item{std}{standard error}

\item{settings}{initial model specific settings}

\item{model}{ODE system}

\item{mcmc_component}{used sampling algorithm}

\item{loglikelihood_func}{used likelihood function}

\item{gibbs_update}{used gibbs algorithm}

\item{ode_sol}{used ode solver}

\item{measFunc}{link function to match observations with modeled states}

\item{numbertrialsstep}{number of sampels per timepoint. This should be at least 10.}

\item{numbertrialseps}{number of samples per mcmc step. This should be greater than numberStates*500.}

\item{numbertrialinner}{number of inner samples. This should be greater 15. High values have direct influnce on the runtime.}

\item{lambda}{inital shrinkage parameter.}

\item{Grad_correct}{used for intial mcmc step size calculation}

\item{alpha}{mcmc tuning paramter}

\item{beta}{mcmc tunig parameter}
}
\value{
returns a results-object with default plot function
}
\description{
Full Bayesian algortihm to detect hidden inputs in ODE based models.The algortihm 
is an extention of the Dynamic Elastic Net algorithm (Engelhardt et al. 2016) inpiered by the Elastic-Net Regression.
}
\examples{
#### clear workspace, load package, remove graphics ####

rm(list=ls())
devtools::load_all()
graphics.off()

#### setze initialen zustand, parameter und Zeitpunkte der Auswertung durch deSolve ####
N = 10^0.31
x0 = c(N, 0, 0, 0)
y <- c(X = x0)

# parameter des modells
parameters = c("k1"=2.4290, "k2"=975.4280, "k3"=0.1157, "k4"= 0, "s1"=10^-0.21, "s2"=10^-0.34)
#parameters = 10^c("k1"=0.31, "k2"=-1, "k3"=-0.49, "k4"= 0.42, "s1"=-0.21, "s2"=-0.34)


evalTimes <- c( 0.0208,  0.1098,   0.2696,    0.4999,    0.8002,    1.1697,    1.6077,    2.1129,    2.6843,    3.3205,    4.0200,    4.7811,    5.6020,    6.4808,    7.4154,    8.4035,    9.4429,   10.5310, 11.6653,   12.8431,   14.0616,   15.3179,   16.6090,   17.9319,   19.2834,   20.6603,   22.0594,   23.4773,   24.9107,   26.3561,   27.8102,   29.2695,   30.7305,   32.1898,   33.6439,   35.0893, 36.5227,   37.9406,   39.3397,   40.7166,   42.0681,   43.3910,   44.6821,   45.9384,   47.1569,   48.3347,   49.4690,   50.5571,   51.5965,   52.5846,   53.5192,   54.3980,   55.2189,   55.9800, 56.6795,   57.3157,   57.8871,   58.3923,   58.8303,   59.1998,   59.5001,   59.7304,   59.8902,   59.9792)

inputData                    <- read.table('http://jeti.uni-freiburg.de/PNAS_Swameye_Data/DATA1_hall_inp')
inputData[nrow(inputData),2] <- 0.009
colnames(inputData)          <- c('t','u')
measure                      <- read.table('http://jeti.uni-freiburg.de/PNAS_Swameye_Data/DATA1_hall')
colnames(measure)            <- c("time","STAT5p_cyt" ,"sd_STAT5p_cyt","STAT5ptot_cyt","sd_STAT5ptot_cyt")

sd                           <- cbind(measure['time'],measure['sd_STAT5p_cyt'],measure['sd_STAT5ptot_cyt'])

y                            <- cbind(measure['time'],((measure['STAT5ptot_cyt']/parameters['s2'])-(measure['STAT5p_cyt']/parameters['s1'])),measure['STAT5p_cyt'],measure['STAT5ptot_cyt'],(x0[1]-(measure['STAT5ptot_cyt']/parameters['s2']))/2/(1400/450))
y[y<0]                       <- 0
colnames(y)                  <- c("time", "STAT5" ,"STAT5p_cyt","STAT5ptot_cyt","STAT5_n")



modelJakStat  <- function(t, x, parameters, input) {
  with (as.list(parameters),{
    
    k1 = parameters[1]
    k2 = parameters[2]
    k3 = parameters[3]

    
    
    u <- input$u(t)
    
    dx1 = -k1 * x[1]  * u
    dx2 = k1 *  x[1]  * u - k2 * x[2]^2
    dx3 = -k3*x[3] + 0.5*k2*x[2]*x[2]
    dx4 = k3 * x[3]

    
    list(c(dx1 ,dx2 ,dx3 ,dx4 ))
  })
}

objectiveJakStat  <- function(index,y,parameter){
  
if (index == 1){
    return(y[1])
  }
  if (index == 2){
    return(parameter[1] * (y[2] + 2 * y[3]))
  }
  if (index == 3){
    return(parameter[2] * (y[1] + y[2] + 2 * y[3]))
  }
  if (index == 4){
    return(y[4])
  }
  
}


A <- BDEN(observation_time   = measure[['time']],
     observations       = y,
     initialvalues      = x0,
     parameters         = parameters,
     inputData          = as.matrix(inputData),
     numberstates       = length(x0),
     std                = sd,
     settings           = SETTINGS,
     mcmc_component     = MCMC_component,
     loglikelihood_func = LOGLIKELIHOOD_func,
     gibbs_update       = GIBBS_update,
     ode_sol            = ode_solv,
     model              = modelJakStat,
     measFunc           = objectiveJakStat)


}
